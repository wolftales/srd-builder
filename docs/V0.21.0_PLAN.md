# v0.21.0 Plan: Cross-Reference Validation & Build-Time Verification

**Created:** December 23, 2025
**Status:** IN PROGRESS - Phase 2
**Effort:** Medium (~1 week)
**Priority:** HIGH - Enables client-side cross-dataset queries

---

## CRITICAL BUG FIXES - Data Model Regression

### Issue 1: Postprocessing Was Discarding type_id Fields

**Root Cause:** In `postprocess/monsters.py` (line 194), the `structure_defenses()` function was filtering damage resistance/immunity/vulnerability entries to only preserve `{"type", "qualifier"}`, inadvertently **discarding the `type_id` field** that `parse_monsters.py` had correctly added.

**Impact:**
- Broke cross-reference validation (no type_id to validate against)
- Made reverse lookups impossible (can't index by type_id that doesn't exist)
- Regression from v0.19.0 cross-reference enhancement work

**Fix Applied:**
```python
# BEFORE (discarded type_id):
normalized = {k: v for k, v in entry.items() if k in {"type", "qualifier"}}

# AFTER (preserves all reference fields):
normalized = {k: v for k, v in entry.items() if k in {"type", "type_id", "qualifier", "conditions"}}
```

### Issue 2: Spell Damage type_id Missing Prefix

**Root Cause:** In `parse/parse_spells.py` (line 391), `_extract_damage()` was setting `type_id` to just the damage type name (e.g., "fire") instead of the full prefixed ID ("damage_type:fire").

**Fix Applied:**
```python
# BEFORE: "type_id": damage_type
# AFTER: "type_id": f"damage_type:{damage_type}"
```

### Issue 3: Monster Damage type_id Missing Prefix

**Root Cause:** In `parse/parse_monsters.py`, `_extract_damage_type_id()` was returning just the type name without prefix.

**Fix Applied:**
```python
# BEFORE: return "fire"
# AFTER: return "damage_type:fire"
```

**Verification:**
- âœ… Cross-reference indexes now populated (spells_by_damage_type: 13, monsters_immune_to_damage_type: 8, etc.)
- âœ… All tests passing (14 total: 8 cross-reference + 6 validation)
- âœ… Data model consistent across all datasets

**Remaining Issues:**
- 3 parsing edge cases creating invalid type_ids:
  - `"piercing and slashing"` â†’ `damage_type:piercing_and_slashing` (should split to multiple refs)
  - `"damage from spells"` â†’ `damage_type:damage` (not a valid damage type)
  - `"nonmagical bludgeoning, piercing, and slashing"` â†’ `damage_type:nonmagical_bludgeoning` (qualifier should be separate)
- 2 missing monk features (ki, ki_empowered_strikes) - data completeness issue, not bug

**Note:** These edge cases are **detected by the validation system** and don't block v0.21.0. They represent complex damage descriptions that need enhanced parsing logic. The validation system working correctly IS the win here - it caught these issues that were previously silent.

**Cleanup tracked in Phase 3.5** (after documentation, before metrics).

---

## Executive Summary

v0.21.0 completes the cross-reference system started in v0.19.0 and enabled by v0.20.0's atomic datasets. This release adds **build-time validation** for all cross-references and ensures data integrity through automated checks.

### Key Deliverables
1. Build-time cross-reference validation (all type_id fields verified)
2. Enhanced index.json with reverse lookups (spells_by_condition, etc.)
3. Referential integrity test suite
4. Cross-dataset query documentation

### Relationship to Previous Releases
- **v0.19.0:** Added type_id fields to prepare for validation (cross-reference enhancement)
- **v0.20.0:** Created atomic reference datasets (damage_types, ability_scores, skills, weapon_properties)
- **v0.21.0:** Validates all type_ids resolve correctly + enables reverse queries

---

## Background: The Cross-Reference Journey

### Current State (v0.20.0)

**What We Have:**
- âœ… 17 datasets with structured data
- âœ… 4 atomic reference datasets (v0.20.0)
- âœ… Inline references with type_id fields (monsters, spells, etc.)
- âœ… Basic indexes (by_name, by_cr, by_level)

**Example Cross-Reference (v0.19.0 pattern):**
```json
// Monster damage reference
{
  "damage": [
    {
      "type": "fire",
      "type_id": "damage_type:fire",  // References damage_types.json
      "dice": "2d6"
    }
  ],
  "saving_throw": {
    "ability": "dexterity",
    "ability_id": "ability:dexterity",  // References ability_scores.json
    "dc": 15
  }
}
```

**The Gap:**
- âŒ No validation that referenced IDs actually exist
- âŒ Can't query "all spells that inflict poisoned condition"
- âŒ Can't query "all monsters immune to fire damage"
- âŒ Broken references silent until runtime

### v0.21.0 Goal: Close the Loop

**Build-Time Validation:**
```python
# During build, verify every type_id exists
def validate_damage_types(datasets):
    damage_type_ids = {dt['id'] for dt in datasets['damage_types']['items']}

    for monster in datasets['monsters']['items']:
        for dmg in monster.get('damage', []):
            type_id = dmg.get('type_id')
            if type_id and type_id not in damage_type_ids:
                raise ValueError(f"Invalid damage type in {monster['id']}: {type_id}")
```

**Reverse Lookups:**
```json
// index.json gains new cross-reference indexes
{
  "cross_references": {
    "spells_by_damage_type": {
      "damage_type:fire": ["spell:fireball", "spell:fire_bolt", ...]
    },
    "monsters_immune_to_damage_type": {
      "damage_type:fire": ["monster:fire_elemental", "monster:red_dragon", ...]
    },
    "spells_requiring_ability_save": {
      "ability:dexterity": ["spell:fireball", "spell:lightning_bolt", ...]
    }
  }
}
```

---

## Phase 1: Build-Time Validation (3-4 days)

### Goal
Verify all cross-references resolve during build, fail fast on broken references.

### Implementation

**1. Create Validation Module**

File: `src/srd_builder/validate_references.py`

```python
"""Cross-reference validation for build-time integrity checks."""

from typing import Any
from collections import defaultdict


class ReferenceValidator:
    """Validates cross-dataset references during build."""

    def __init__(self, datasets: dict[str, Any]):
        """Initialize with all datasets."""
        self.datasets = datasets
        self.errors: list[str] = []
        self.warnings: list[str] = []

        # Build ID indexes for fast lookup
        self._build_id_indexes()

    def _build_id_indexes(self) -> None:
        """Build fast lookup indexes for all entity IDs."""
        self.damage_type_ids = {
            dt['id'] for dt in self.datasets.get('damage_types', {}).get('items', [])
        }
        self.ability_ids = {
            ab['id'] for ab in self.datasets.get('ability_scores', {}).get('items', [])
        }
        self.skill_ids = {
            sk['id'] for sk in self.datasets.get('skills', {}).get('items', [])
        }
        self.condition_ids = {
            cond['id'] for cond in self.datasets.get('conditions', {}).get('items', [])
        }
        self.spell_ids = {
            sp['id'] for sp in self.datasets.get('spells', {}).get('items', [])
        }
        self.feature_ids = {
            feat['id'] for feat in self.datasets.get('features', {}).get('items', [])
        }

    def validate_all(self) -> bool:
        """Run all validation checks. Returns True if valid."""
        self.validate_damage_type_refs()
        self.validate_ability_refs()
        self.validate_skill_refs()
        self.validate_condition_refs()
        self.validate_spell_refs()
        self.validate_feature_refs()

        if self.errors:
            print(f"\nâŒ Found {len(self.errors)} reference errors:")
            for error in self.errors:
                print(f"  - {error}")
            return False

        if self.warnings:
            print(f"\nâš ï¸  Found {len(self.warnings)} warnings:")
            for warning in self.warnings:
                print(f"  - {warning}")

        return True

    def validate_damage_type_refs(self) -> None:
        """Validate all damage type_id references."""
        # Check monsters
        for monster in self.datasets.get('monsters', {}).get('items', []):
            # Damage arrays
            for dmg in monster.get('damage', []):
                self._check_ref(
                    dmg.get('type_id'),
                    self.damage_type_ids,
                    f"Monster {monster['id']} damage type"
                )

            # Resistances, immunities, vulnerabilities
            for resist in monster.get('damage_resistances', []):
                self._check_ref(
                    resist.get('type_id'),
                    self.damage_type_ids,
                    f"Monster {monster['id']} resistance"
                )

        # Check spells
        for spell in self.datasets.get('spells', {}).get('items', []):
            for dmg in spell.get('damage', []):
                self._check_ref(
                    dmg.get('type_id'),
                    self.damage_type_ids,
                    f"Spell {spell['id']} damage type"
                )

    def validate_ability_refs(self) -> None:
        """Validate all ability_id references."""
        # Check monsters
        for monster in self.datasets.get('monsters', {}).get('items', []):
            for save in monster.get('saving_throws', []):
                self._check_ref(
                    save.get('ability_id'),
                    self.ability_ids,
                    f"Monster {monster['id']} saving throw"
                )

        # Check spells
        for spell in self.datasets.get('spells', {}).get('items', []):
            save = spell.get('saving_throw', {})
            self._check_ref(
                save.get('ability_id'),
                self.ability_ids,
                f"Spell {spell['id']} saving throw"
            )

    def validate_skill_refs(self) -> None:
        """Validate all skill_id references."""
        for monster in self.datasets.get('monsters', {}).get('items', []):
            for skill in monster.get('skills', []):
                self._check_ref(
                    skill.get('skill_id'),
                    self.skill_ids,
                    f"Monster {monster['id']} skill"
                )

    def validate_condition_refs(self) -> None:
        """Validate all condition_id references."""
        # Check monsters
        for monster in self.datasets.get('monsters', {}).get('items', []):
            for cond in monster.get('condition_immunities', []):
                self._check_ref(
                    cond.get('id'),
                    self.condition_ids,
                    f"Monster {monster['id']} condition immunity"
                )

        # Check spells (if they inflict conditions)
        for spell in self.datasets.get('spells', {}).get('items', []):
            for cond in spell.get('inflicts_conditions', []):
                self._check_ref(
                    cond.get('condition_id'),
                    self.condition_ids,
                    f"Spell {spell['id']} inflicted condition"
                )

    def validate_spell_refs(self) -> None:
        """Validate spell cross-references (innate casting, magic items)."""
        # Check monster innate spellcasting
        for monster in self.datasets.get('monsters', {}).get('items', []):
            spellcasting = monster.get('innate_spellcasting', {})
            for spell_ref in spellcasting.get('spells', []):
                self._check_ref(
                    spell_ref.get('spell_id'),
                    self.spell_ids,
                    f"Monster {monster['id']} innate spell"
                )

        # Check magic items that grant spells
        for item in self.datasets.get('magic_items', {}).get('items', []):
            for spell_ref in item.get('grants_spells', []):
                self._check_ref(
                    spell_ref.get('spell_id'),
                    self.spell_ids,
                    f"Magic item {item['id']} granted spell"
                )

    def validate_feature_refs(self) -> None:
        """Validate feature cross-references (classes, lineages)."""
        # Check classes
        for cls in self.datasets.get('classes', {}).get('items', []):
            for feature_id in cls.get('features', []):
                self._check_ref(
                    feature_id,
                    self.feature_ids,
                    f"Class {cls['id']} feature"
                )

        # Check lineages
        for lineage in self.datasets.get('lineages', {}).get('items', []):
            for feature_id in lineage.get('features', []):
                self._check_ref(
                    feature_id,
                    self.feature_ids,
                    f"Lineage {lineage['id']} feature"
                )

    def _check_ref(
        self,
        ref_id: str | None,
        valid_ids: set[str],
        context: str
    ) -> None:
        """Check single reference, record error if invalid."""
        if not ref_id:
            return  # Optional reference

        if ref_id not in valid_ids:
            self.errors.append(f"{context}: {ref_id} not found")


def validate_references(datasets: dict[str, Any]) -> bool:
    """Validate all cross-references in datasets. Returns True if valid."""
    validator = ReferenceValidator(datasets)
    return validator.validate_all()
```

**2. Integrate into Build**

File: `src/srd_builder/build.py`

```python
from .validate_references import validate_references

def build(ruleset: str, output_dir: Path) -> BuildReport:
    """Build datasets with cross-reference validation."""

    # ... existing build logic ...

    # NEW: Validate cross-references before writing
    print("\nðŸ” Validating cross-references...")
    if not validate_references(datasets):
        raise ValueError("Cross-reference validation failed. Fix errors and rebuild.")

    print("âœ… All cross-references valid")

    # ... write datasets ...
```

**3. Add Tests**

File: `tests/test_validate_references.py`

```python
"""Tests for cross-reference validation."""

import pytest
from srd_builder.validate_references import ReferenceValidator


def test_valid_damage_type_refs():
    """Valid damage type references pass validation."""
    datasets = {
        'damage_types': {
            'items': [{'id': 'damage_type:fire'}]
        },
        'monsters': {
            'items': [
                {
                    'id': 'monster:dragon',
                    'damage': [{'type_id': 'damage_type:fire', 'dice': '2d6'}]
                }
            ]
        }
    }

    validator = ReferenceValidator(datasets)
    validator.validate_damage_type_refs()
    assert len(validator.errors) == 0


def test_invalid_damage_type_refs():
    """Invalid damage type references fail validation."""
    datasets = {
        'damage_types': {
            'items': [{'id': 'damage_type:fire'}]
        },
        'monsters': {
            'items': [
                {
                    'id': 'monster:dragon',
                    'damage': [{'type_id': 'damage_type:cold', 'dice': '2d6'}]  # Not in damage_types
                }
            ]
        }
    }

    validator = ReferenceValidator(datasets)
    validator.validate_damage_type_refs()
    assert len(validator.errors) == 1
    assert 'damage_type:cold' in validator.errors[0]


# Add similar tests for abilities, skills, conditions, etc.
```

### Deliverables
- âœ… validate_references.py module (full cross-reference validation)
- âœ… Build integration (fails fast on broken refs)
- âœ… Test suite (10+ validation tests)
- âœ… Zero broken references in current datasets

**Effort:** 3-4 days
- Validator implementation: 2 days
- Build integration: 1 day
- Tests: 1 day

---

## Phase 2: Enhanced Indexes (2-3 days)

### Goal
Add reverse lookup indexes for common cross-dataset queries.

### Implementation

**1. Extend Indexer**

File: `src/srd_builder/assemble/indexer.py`

```python
def build_cross_reference_indexes(datasets: dict) -> dict:
    """Build reverse lookup indexes for cross-dataset queries."""
    indexes = {
        'spells_by_damage_type': defaultdict(list),
        'monsters_by_damage_type': defaultdict(list),
        'monsters_immune_to_damage_type': defaultdict(list),
        'spells_by_condition': defaultdict(list),
        'monsters_by_condition_immunity': defaultdict(list),
        'spells_requiring_ability_save': defaultdict(list),
        'features_by_class': defaultdict(list),
        'features_by_lineage': defaultdict(list),
        'innate_spells_by_monster': defaultdict(list),
        'spells_granted_by_magic_item': defaultdict(list),
    }

    # Index spells by damage type
    for spell in datasets.get('spells', {}).get('items', []):
        for dmg in spell.get('damage', []):
            if type_id := dmg.get('type_id'):
                indexes['spells_by_damage_type'][type_id].append(spell['id'])

    # Index monsters by damage type (from attacks)
    for monster in datasets.get('monsters', {}).get('items', []):
        for dmg in monster.get('damage', []):
            if type_id := dmg.get('type_id'):
                indexes['monsters_by_damage_type'][type_id].append(monster['id'])

        # Index immunities
        for immunity in monster.get('damage_immunities', []):
            if type_id := immunity.get('type_id'):
                indexes['monsters_immune_to_damage_type'][type_id].append(monster['id'])

        # Index condition immunities
        for cond in monster.get('condition_immunities', []):
            if cond_id := cond.get('id'):
                indexes['monsters_by_condition_immunity'][cond_id].append(monster['id'])

        # Index innate spells
        spellcasting = monster.get('innate_spellcasting', {})
        for spell_ref in spellcasting.get('spells', []):
            if spell_id := spell_ref.get('spell_id'):
                indexes['innate_spells_by_monster'][monster['id']].append(spell_id)

    # Index spells by inflicted conditions
    for spell in datasets.get('spells', {}).get('items', []):
        for cond in spell.get('inflicts_conditions', []):
            if cond_id := cond.get('condition_id'):
                indexes['spells_by_condition'][cond_id].append(spell['id'])

        # Index by ability save
        if save := spell.get('saving_throw', {}).get('ability_id'):
            indexes['spells_requiring_ability_save'][save].append(spell['id'])

    # Index features by class
    for cls in datasets.get('classes', {}).get('items', []):
        for feature_id in cls.get('features', []):
            indexes['features_by_class'][cls['id']].append(feature_id)

    # Index features by lineage
    for lineage in datasets.get('lineages', {}).get('items', []):
        for feature_id in lineage.get('features', []):
            indexes['features_by_lineage'][lineage['id']].append(feature_id)

    # Index magic item spell grants
    for item in datasets.get('magic_items', {}).get('items', []):
        for spell_ref in item.get('grants_spells', []):
            if spell_id := spell_ref.get('spell_id'):
                indexes['spells_granted_by_magic_item'][item['id']].append(spell_id)

    # Convert defaultdicts to regular dicts for JSON serialization
    return {key: dict(value) for key, value in indexes.items()}
```

**2. Update index.json Structure**

```json
{
  "_meta": {
    "generated_by": "srd-builder v0.21.0",
    "schema_version": "2.0.0",
    "entity_count": 1548
  },
  "by_id": {
    "monster:aboleth": {...},
    "spell:fireball": {...}
  },
  "by_name": {
    "aboleth": "monster:aboleth",
    "fireball": "spell:fireball"
  },
  "cross_references": {
    "spells_by_damage_type": {
      "damage_type:fire": ["spell:fireball", "spell:fire_bolt", "spell:burning_hands"],
      "damage_type:cold": ["spell:ice_storm", "spell:cone_of_cold"]
    },
    "monsters_immune_to_damage_type": {
      "damage_type:fire": ["monster:fire_elemental", "monster:red_dragon"],
      "damage_type:poison": ["monster:skeleton", "monster:zombie"]
    },
    "spells_by_condition": {
      "condition:paralyzed": ["spell:hold_person", "spell:hold_monster"],
      "condition:poisoned": ["spell:poison_spray", "spell:cloudkill"]
    },
    "monsters_by_condition_immunity": {
      "condition:charmed": ["monster:skeleton", "monster:zombie"],
      "condition:frightened": ["monster:skeleton"]
    },
    "spells_requiring_ability_save": {
      "ability:dexterity": ["spell:fireball", "spell:lightning_bolt"],
      "ability:wisdom": ["spell:hold_person", "spell:charm_person"]
    },
    "features_by_class": {
      "class:barbarian": ["feature:rage", "feature:unarmored_defense"],
      "class:wizard": ["feature:spellcasting", "feature:arcane_recovery"]
    },
    "features_by_lineage": {
      "lineage:dwarf": ["feature:darkvision", "feature:dwarven_resilience"],
      "lineage:elf": ["feature:darkvision", "feature:keen_senses"]
    },
    "innate_spells_by_monster": {
      "monster:drow": ["spell:dancing_lights", "spell:faerie_fire"],
      "monster:archmage": ["spell:shield", "spell:fireball"]
    },
    "spells_granted_by_magic_item": {
      "magic_item:wand_of_fireballs": ["spell:fireball"],
      "magic_item:staff_of_healing": ["spell:cure_wounds", "spell:lesser_restoration"]
    }
  }
}
```

**3. Usage Examples**

Query: "Which spells inflict the paralyzed condition?"
```python
index = load_json('index.json')
spell_ids = index['cross_references']['spells_by_condition']['condition:paralyzed']
# Result: ["spell:hold_person", "spell:hold_monster"]
```

Query: "Which monsters are immune to fire damage?"
```python
monster_ids = index['cross_references']['monsters_immune_to_damage_type']['damage_type:fire']
# Result: ["monster:fire_elemental", "monster:red_dragon", ...]
```

Query: "Which features does a dwarf get?"
```python
feature_ids = index['cross_references']['features_by_lineage']['lineage:dwarf']
# Result: ["feature:darkvision", "feature:dwarven_resilience", "feature:stonecunning"]
```

### Deliverables
- âœ… Cross-reference indexes in index.json
- âœ… ~10 reverse lookup patterns
- âœ… Query examples in documentation

**Effort:** 2-3 days
- Indexer implementation: 1-2 days
- Testing: 1 day

---

## Phase 3: Documentation (1 day)

### Goal
Document cross-reference patterns and query capabilities.

### Deliverables

**1. Update INTEGRATION.md**

Add section: "Cross-Reference Queries"

```markdown
## Cross-Reference Queries

srd-builder v0.21.0 enables client-side cross-dataset queries without a server.

### Pattern 1: Direct Reference Navigation

Follow inline references from entities to their targets:

```javascript
// Load datasets
const monsters = await loadJSON('monsters.json');
const damageTypes = await loadJSON('damage_types.json');

// Get monster's damage type details
const dragon = monsters.items.find(m => m.id === 'monster:red_dragon');
const fireAttack = dragon.damage[0];  // {type: "fire", type_id: "damage_type:fire", dice: "4d6"}

// Navigate to full damage type description
const damageTypeId = fireAttack.type_id;
const fireType = damageTypes.items.find(dt => dt.id === damageTypeId);
console.log(fireType.description);  // "Fire damage represents..."
```

### Pattern 2: Reverse Lookups

Use cross-reference indexes for "what uses this?" queries:

```javascript
const index = await loadJSON('index.json');

// Find all spells that inflict paralyzed condition
const paralyzingSpells = index.cross_references.spells_by_condition['condition:paralyzed'];
// Result: ["spell:hold_person", "spell:hold_monster"]

// Find all monsters immune to fire
const fireImmuneMonsters = index.cross_references.monsters_immune_to_damage_type['damage_type:fire'];
// Result: ["monster:fire_elemental", "monster:red_dragon", ...]

// Find features granted by dwarf lineage
const dwarfFeatures = index.cross_references.features_by_lineage['lineage:dwarf'];
// Result: ["feature:darkvision", "feature:dwarven_resilience", ...]
```

### Available Cross-Reference Indexes

| Index Name | Description | Example Query |
|------------|-------------|---------------|
| `spells_by_damage_type` | Spells dealing specific damage | Fire spells |
| `monsters_by_damage_type` | Monsters with specific damage attacks | Cold damage dealers |
| `monsters_immune_to_damage_type` | Monsters immune to damage type | Fire immune creatures |
| `spells_by_condition` | Spells inflicting conditions | Paralysis spells |
| `monsters_by_condition_immunity` | Monsters immune to conditions | Charm immune undead |
| `spells_requiring_ability_save` | Spells by saving throw | Dex save spells |
| `features_by_class` | Features granted by class | Barbarian features |
| `features_by_lineage` | Features granted by lineage | Elf features |
| `innate_spells_by_monster` | Innate spells by monster | Drow spells |
| `spells_granted_by_magic_item` | Spells from magic items | Wand spells |

### Build-Time Validation

All cross-references are validated during build. Broken references cause build failure:

```
âŒ Found 2 reference errors:
  - Monster monster:dragon damage type: damage_type:arcane not found
  - Spell spell:hold_person inflicted condition: condition:petrified not found
```

This guarantees referential integrity at the data level.
```

**2. Add Query Examples to README.md**

Show real-world use cases for cross-references.

**3. Create CROSS_REFERENCES.md**

Comprehensive guide to cross-reference system:
- ID conventions (`damage_type:`, `ability:`, `condition:`, etc.)
- Inline reference patterns
- Reverse lookup patterns
- Build-time validation
- Schema evolution notes

**Effort:** 1 day

---

## Phase 3.5: Data Quality Cleanup (0.5 day)

### Goal
Fix parsing edge cases detected by validation system.

### Issues to Fix

**1. Complex Damage Type Parsing**

Current behavior creates invalid single type_ids from multi-type descriptions:

| Raw Text | Current type_id | Should Be |
|----------|-----------------|-----------|
| `"piercing and slashing"` | `damage_type:piercing_and_slashing` | Split to multiple entries |
| `"bludgeoning, piercing, and slashing"` | `damage_type:bludgeoning` | Split to 3 entries |
| `"damage from spells"` | `damage_type:damage` | `qualifier: "from spells"` only |

**Fix in:** `src/srd_builder/parse/parse_monsters.py::_extract_damage_type_id()`

```python
def _normalize_defense_entry(entry: dict) -> list[dict]:
    """Split multi-type damage entries into individual type_id references."""
    damage_type = entry.get("type", "")

    # Handle "damage from X" (not a real damage type)
    if damage_type.lower().startswith("damage "):
        return [{"qualifier": damage_type}]

    # Split compound types: "bludgeoning, piercing, and slashing"
    types = re.split(r',\s*(?:and\s+)?|\s+and\s+', damage_type)
    result = []
    for dt in types:
        dt_clean = dt.strip().lower()
        if dt_clean in VALID_DAMAGE_TYPES:
            result.append({
                "type": dt_clean,
                "type_id": f"damage_type:{dt_clean}",
                "conditions": entry.get("conditions"),
            })
    return result if result else [entry]  # Fallback to original if no valid types
```

**2. Missing Monk Features**

Add to features dataset:
- `feature:ki` - Core monk resource
- `feature:ki_empowered_strikes` - Monk ability at level 3

**Fix in:** `rulesets/srd_5_1/static/features.yaml` or via extraction enhancement

### Verification

After fixes:
```bash
python -m srd_builder.build --ruleset srd_5_1 --out dist 2>&1 | grep -A5 "Validating"
# Expected: âœ… All cross-references valid
```

**Effort:** 0.5 day

---

## Phase 4: Quality Metrics & Reporting (1 day)

### Goal
Report cross-reference coverage and data completeness.

### Implementation

**Create Cross-Reference Report**

File: `scripts/cross_reference_report.py`

```python
"""Generate cross-reference coverage report."""

def analyze_cross_references(datasets: dict) -> dict:
    """Analyze cross-reference completeness."""

    report = {
        'damage_type_refs': {
            'total_monsters_with_damage': 0,
            'monsters_with_type_id': 0,
            'total_spells_with_damage': 0,
            'spells_with_type_id': 0,
        },
        'ability_refs': {
            'total_saves': 0,
            'saves_with_ability_id': 0,
        },
        'condition_refs': {
            'total_immunities': 0,
            'immunities_with_id': 0,
        },
        'reverse_indexes': {
            'spells_by_damage_type_count': 0,
            'monsters_immune_count': 0,
            'features_by_class_count': 0,
        }
    }

    # Analyze damage type coverage
    for monster in datasets['monsters']['items']:
        if monster.get('damage'):
            report['damage_type_refs']['total_monsters_with_damage'] += 1
            if monster['damage'][0].get('type_id'):
                report['damage_type_refs']['monsters_with_type_id'] += 1

    # ... similar analysis for other reference types ...

    # Calculate percentages
    report['coverage'] = {
        'damage_types': f"{report['damage_type_refs']['monsters_with_type_id'] / report['damage_type_refs']['total_monsters_with_damage'] * 100:.1f}%",
        'abilities': f"{report['ability_refs']['saves_with_ability_id'] / report['ability_refs']['total_saves'] * 100:.1f}%",
    }

    return report


if __name__ == '__main__':
    datasets = load_all_datasets()
    report = analyze_cross_references(datasets)
    print_report(report)
```

**Expected Output:**
```
Cross-Reference Coverage Report (v0.21.0)
==========================================

Damage Type References:
  Monsters with damage: 287/317 (90.5%)
  Monsters with type_id: 287/287 (100%)
  Spells with damage: 183/319 (57.4%)
  Spells with type_id: 183/183 (100%)

Ability References:
  Saving throws: 156
  With ability_id: 156/156 (100%)

Condition References:
  Immunities: 89
  With condition_id: 89/89 (100%)

Reverse Indexes:
  Spells by damage type: 13 damage types covered
  Monsters immune to damage: 13 damage types covered
  Features by class: 12 classes covered
  Features by lineage: 13 lineages covered

âœ… All cross-references valid
âœ… 100% coverage on existing references
```

**Effort:** 1 day

---

## Success Criteria

### Validation âœ…
- âœ… All type_id references validate during build
- âœ… Build fails fast on broken references
- âœ… Zero broken references in v0.21.0 release
- âœ… Validation test suite (10+ tests)

### Indexes âœ…
- âœ… Cross-reference indexes in index.json
- âœ… ~10 reverse lookup patterns
- âœ… All major cross-dataset relationships covered

### Documentation âœ…
- âœ… INTEGRATION.md updated with query examples
- âœ… CROSS_REFERENCES.md comprehensive guide
- âœ… README.md shows real-world use cases
- âœ… All query patterns documented

### Quality âœ…
- âœ… Cross-reference coverage report
- âœ… 100% validation on existing references
- âœ… All 278+ tests passing
- âœ… Build time impact < 10 seconds

---

## Timeline

| Phase | Duration | Cumulative |
|-------|----------|------------|
| Phase 1: Build Validation | 3-4 days | 3-4 days |
| Phase 2: Enhanced Indexes | 2-3 days | 5-7 days |
| Phase 3: Documentation | 1 day | 6-8 days |
| Phase 4: Quality Metrics | 1 day | 7-9 days |
| **Total** | **~1-1.5 weeks** | **7-9 days** |

---

## Breaking Changes

**None Expected**
- Cross-reference validation is additive (no schema changes)
- Indexes extend index.json (backward compatible)
- Existing queries continue to work

**Schema Version:** Stays at current versions (validation-only release)

---

## Future Work (v0.22.0+)

### Remaining Cross-References (v0.22.0)
1. **Lineages â†’ Features**
   - Add `features: string[]` to lineage schema
   - Similar to classes pattern

2. **Spells â†’ Conditions**
   - Add `inflicts_conditions: ConditionRef[]` to spell schema
   - Parse descriptions for condition keywords

3. **Monsters â†’ Innate Spells**
   - Add `innate_spellcasting.spells: SpellRef[]` to monster schema
   - Parse spellcasting trait text

4. **Magic Items â†’ Spells**
   - Add `grants_spells: SpellRef[]` to magic_item schema
   - Parse item descriptions for spell grants

### Multi-Version Support (v0.23.0+)
- Terminology system (race â†’ species transition)
- Version-specific aliases
- Cross-version compatibility layer

---

## Dependencies

**Requires:**
- v0.20.0 atomic datasets (damage_types, ability_scores, skills, weapon_properties)
- Current cross-reference patterns from v0.19.0

**Enables:**
- Client-side cross-dataset queries
- Referential integrity guarantees
- Future multi-version support (v0.23.0+)
- Advanced query capabilities (v0.22.0+)

---

## Open Questions

1. **Performance:** Will validation add significant build time?
   - **Answer:** Likely < 5 seconds (simple set lookups)
   - Measure and optimize if needed

2. **Coverage:** Should we validate missing optional references?
   - **Answer:** No - warn only, don't fail build
   - Some entities legitimately lack references

3. **Reporting:** Include coverage report in build output?
   - **Answer:** Yes, but as optional verbose flag
   - Default: only show errors/warnings

4. **Future:** How to handle version-specific references (5.1 vs 5.2.1)?
   - **Answer:** Defer to v0.23.0 terminology system
   - Current implementation is version-agnostic

---

## References

- Original plan: docs/ROADMAP.md Â§ v0.19.0, v0.20.0, v0.21.0
- Claude proposal: docs/reports/srd_builder_v1_roadmap_proposal_claude.md Â§ v0.22.0
- v0.20.0 plan: docs/V0.20.0_PLAN.md
- Architecture: docs/ARCHITECTURE.md Â§ "Cross-Reference Patterns"
